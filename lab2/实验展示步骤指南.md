# Lab 2 实验展示步骤指南 📋

## 📋 结果验证清单

本节内容需要在报告和检查过程中展示，以确保你成功完成了实验：

### ✅ 验证任务 1：Wireshark 抓包验证自学习交换机
- 运行 `self_learning_switch.py` 与 `topo_1.py`
- 对 `h3-eth0` 抓包
- 使用 `h4 ping h2` 后
- **预期结果**：h3 从 ARP 后未收到过 h4 与 h2 之间通信的数据包

### ✅ 验证任务 2：MAC 地址和通信路径分析
- 运行 `self_learning_switch.py` 与 `topo_1.py`
- 使用 `h4 ping h2`
- 通过控制器输出，指出：
  - h4、h2 的 MAC 地址
  - 通信路径涉及的交换机以及端口号

### ✅ 验证任务 3：hard_timeout 参数对比
- 分别设置 `hard_timeout=5` 与 `hard_timeout=0`
- 在两种场景下运行 `topo_1.py` 与 `self_learning_switch.py`
- 使用 `h4 ping h2`
- 指出控制器输出差异与规律并说明原因

---

## 🚀 验证任务 1：Wireshark 抓包验证

### 步骤 1：准备工作

**打开终端 1（控制器）：**
```bash
cd lab2
source .venv/bin/activate  # 如果使用虚拟环境
```

**打开终端 2（网络拓扑）：**
```bash
cd lab2
```

### 步骤 2：启动控制器

**在终端 1 中：**
```bash
osken-manager self_learning_switch.py
```

**预期输出：**
```
INFO:os_ken.controller.controller:Connected to ('127.0.0.1', 6633)
INFO:os_ken.controller.controller:Connected to ('127.0.0.1', 6634)
...
```

### 步骤 3：启动网络拓扑

**在终端 2 中：**
```bash
sudo ./topo_1.py
```

**预期输出：**
```
*** Creating network
*** Adding controller
*** Adding hosts:
 h1 h2 h3 h4
*** Adding switches:
 s1 s2
*** Adding links:
...
*** Starting controller
*** Starting 2 switches
*** Starting CLI:
mininet>
```

### 步骤 4：启动 Wireshark 抓包

**在 Mininet CLI 中：**
```bash
mininet> h3 wireshark &
```

**重要提示：**
- `&` 符号**不能省略**，用于后台运行 Wireshark
- Wireshark 窗口会自动打开
- 如果 Wireshark 没有自动打开，可能需要手动启动：
  ```bash
  # 在另一个终端执行
  sudo wireshark
  # 然后选择 h3-eth0 接口开始捕获
  ```

### 步骤 5：执行 ping 测试

**在 Mininet CLI 中：**
```bash
mininet> h4 ping -c 10 h2
```

**预期输出：**
```
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.123 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.045 ms
...
--- 10.0.0.2 ping statistics ---
10 packets transmitted, 10 received, 0% packet loss
```

### 步骤 6：分析 Wireshark 抓包结果

**在 Wireshark 窗口中：**

1. **过滤 ARP 包：**
   - 在过滤栏输入：`arp`
   - 应该能看到 ARP Request 和 ARP Reply 包

2. **过滤 ICMP 包（关键验证）：**
   - 在过滤栏输入：`icmp`
   - **预期结果**：**应该为空或只有很少的包**
   - ✅ **成功标志**：h3 不会收到 h4 和 h2 之间的 ICMP 通信包

3. **注意区分 ICMP 和 ICMPv6：**
   - `icmp`：IPv4 的 ICMP 协议（这是我们要验证的）
   - `icmp6`：IPv6 的 ICMP 协议（Linux 系统自动发送，可以忽略）

**截图要求：**
- 截图 1：Wireshark 过滤 `arp` 的结果（显示 ARP 学习过程）
- 截图 2：Wireshark 过滤 `icmp` 的结果（应为空或很少）
- 截图 3：Ping 成功输出（0% packet loss）

### 步骤 7：清理环境

```bash
mininet> exit
sudo mn -c  # 清理 Mininet 环境
```

---

## 🔍 验证任务 2：MAC 地址和通信路径分析

### 步骤 1：启动实验（同任务 1）

**终端 1：**
```bash
cd lab2
source .venv/bin/activate  # 如果需要
osken-manager self_learning_switch.py
```

**终端 2：**
```bash
cd lab2
sudo ./topo_1.py
```

### 步骤 2：执行 ping 测试

**在 Mininet CLI 中：**
```bash
mininet> h4 ping -c 10 h2
```

### 步骤 3：分析控制器输出

**查看终端 1（控制器）的输出：**

**示例输出：**
```
INFO:switch:Packet matched: dpid=2, src=00:00:00:00:00:04, in_port=1, dst=00:00:00:00:00:02, out_port=2
INFO:switch:Packet matched: dpid=1, src=00:00:00:00:00:04, in_port=2, dst=00:00:00:00:00:02, out_port=4
INFO:switch:Packet matched: dpid=4, src=00:00:00:00:00:04, in_port=2, dst=00:00:00:00:00:02, out_port=1
INFO:switch:Packet matched: dpid=4, src=00:00:00:00:00:02, in_port=1, dst=00:00:00:00:00:04, out_port=2
INFO:switch:Packet matched: dpid=1, src=00:00:00:00:00:02, in_port=4, dst=00:00:00:00:00:04, out_port=2
INFO:switch:Packet matched: dpid=2, src=00:00:00:00:00:02, in_port=2, dst=00:00:00:00:00:04, out_port=1
```

### 步骤 4：提取 MAC 地址

**从输出中提取：**

**h4 的 MAC 地址：**
- 从 `src=00:00:00:00:00:04` 可以看出
- **答案**：`00:00:00:00:00:04`

**h2 的 MAC 地址：**
- 从 `dst=00:00:00:00:00:02` 或 `src=00:00:00:00:00:02` 可以看出
- **答案**：`00:00:00:00:00:02`

### 步骤 5：分析通信路径

**去程路径（h4 → h2）：**

分析输出中的 `dpid` 和端口顺序：

```
h4 (00:00:00:00:00:04)
  → s2 (dpid=2, in_port=1 → out_port=2)
  → s1 (dpid=1, in_port=2 → out_port=4)
  → s4 (dpid=4, in_port=2 → out_port=1)
  → h2 (00:00:00:00:00:02)
```

**回程路径（h2 → h4）：**

```
h2 (00:00:00:00:00:02)
  → s4 (dpid=4, in_port=1 → out_port=2)
  → s1 (dpid=1, in_port=4 → out_port=2)
  → s2 (dpid=2, in_port=2 → out_port=1)
  → h4 (00:00:00:00:00:04)
```

**记录表格：**

| 交换机 | 入端口 | 出端口 | 说明 |
|--------|--------|--------|------|
| s2 | 1 | 2 | h4 连接 s2 的端口 1 |
| s1 | 2 | 4 | s2 连接 s1 的端口 2，转发到端口 4 |
| s4 | 2 | 1 | s1 连接 s4 的端口 2，转发到端口 1（h2）|

**截图要求：**
- 截图 1：控制器输出（显示五元组信息）
- 截图 2：绘制的通信路径图（或文字描述）

### 步骤 6：清理环境

```bash
mininet> exit
sudo mn -c
```

---

## ⏱️ 验证任务 3：hard_timeout 参数对比

### 场景 1：hard_timeout=0（流表永久有效）

#### 步骤 1：修改代码

**编辑 `self_learning_switch.py` 第 82 行：**

```python
# 修改为：
self.add_flow(dp, 1, match, actions, hard_timeout=0)
```

#### 步骤 2：启动实验

**终端 1：**
```bash
cd lab2
source .venv/bin/activate  # 如果需要
osken-manager self_learning_switch.py
```

**终端 2：**
```bash
cd lab2
sudo ./topo_1.py
```

#### 步骤 3：执行 ping 测试

**在 Mininet CLI 中：**
```bash
mininet> h4 ping -c 20 h2
```

#### 步骤 4：观察控制器输出（场景 1）

**预期输出规律：**

```
INFO:switch:Packet matched: dpid=2, src=00:00:00:00:00:04, in_port=1, dst=00:00:00:00:00:02, out_port=2
INFO:switch:Packet matched: dpid=1, src=00:00:00:00:00:04, in_port=2, dst=00:00:00:00:00:02, out_port=4
...
（只有前几个包有输出，之后不再输出）
```

**关键观察：**
- ✅ 只在**学习阶段**（前几次 ping）有输出
- ✅ 之后控制器**不再输出**（因为流表永久有效）
- ✅ 交换机直接根据流表转发，不经过控制器

**截图要求：**
- 截图 1：控制器输出（只显示前几次匹配）
- 截图 2：Ping 完整输出（20 个包）

#### 步骤 5：清理环境

```bash
mininet> exit
sudo mn -c
```

---

### 场景 2：hard_timeout=5（流表 5 秒后失效）

#### 步骤 1：修改代码

**编辑 `self_learning_switch.py` 第 82 行：**

```python
# 修改为：
self.add_flow(dp, 1, match, actions, hard_timeout=5)
```

#### 步骤 2：启动实验（重新启动）

**终端 1：**
```bash
# 如果控制器还在运行，先 Ctrl+C 停止
osken-manager self_learning_switch.py
```

**终端 2：**
```bash
sudo ./topo_1.py
```

#### 步骤 3：执行 ping 测试

**在 Mininet CLI 中：**
```bash
mininet> h4 ping -c 20 h2
```

#### 步骤 4：观察控制器输出（场景 2）

**预期输出规律：**

```
INFO:switch:Packet matched: dpid=2, src=00:00:00:00:00:04, in_port=1, dst=00:00:00:00:00:02, out_port=2
INFO:switch:Packet matched: dpid=1, src=00:00:00:00:00:04, in_port=2, dst=00:00:00:00:00:02, out_port=4
...
（持续输出，每隔 5 秒左右重新输出）
```

**关键观察：**
- ✅ **每 5 秒**重新输出匹配信息
- ✅ 因为流表 5 秒后失效，需要重新学习
- ✅ 控制器持续介入转发过程

**截图要求：**
- 截图 1：控制器输出（显示持续匹配）
- 截图 2：Ping 完整输出（20 个包）

#### 步骤 5：清理环境

```bash
mininet> exit
sudo mn -c
```

---

## 📊 对比分析总结

### 输出差异对比表

| 对比项 | hard_timeout=0 | hard_timeout=5 |
|--------|---------------|----------------|
| **输出时机** | 只在学习阶段（前几次） | 每 5 秒持续输出 |
| **输出频率** | 低（只学习一次） | 高（定期重新学习） |
| **控制器介入** | 少（流表永久有效） | 多（流表定期失效） |
| **交换机转发** | 直接根据流表转发 | 需要控制器重新下发流表 |
| **性能影响** | 低延迟，高效 | 较高延迟，需要控制器处理 |

### 原因分析

**hard_timeout=0（永久有效）：**
- 流表一旦下发，**永久保存在交换机中**
- 交换机可以直接根据流表转发，**不需要控制器参与**
- 控制器只在**首次学习**时输出日志
- **优点**：性能好，延迟低
- **缺点**：流表不会自动过期，可能占用交换机资源

**hard_timeout=5（5 秒后失效）：**
- 流表在下发后 **5 秒自动删除**
- 5 秒后，数据包需要重新上送控制器
- 控制器需要**重新学习**并下发流表
- **优点**：流表会自动清理，节省资源
- **缺点**：需要控制器持续介入，增加延迟

**实际应用场景：**
- **hard_timeout=0**：适合稳定的网络环境，主机位置固定
- **hard_timeout=5**：适合动态网络环境，主机可能移动或下线

---

## 📸 实验报告截图清单

### 验证任务 1（3 张截图）
- [ ] Wireshark 过滤 `arp` 的结果
- [ ] Wireshark 过滤 `icmp` 的结果（应为空）
- [ ] Ping 成功输出（0% packet loss）

### 验证任务 2（2 张截图）
- [ ] 控制器输出（五元组信息）
- [ ] 通信路径分析图（或文字描述）

### 验证任务 3（4 张截图）
- [ ] hard_timeout=0 的控制器输出
- [ ] hard_timeout=0 的 Ping 输出
- [ ] hard_timeout=5 的控制器输出
- [ ] hard_timeout=5 的 Ping 输出

---

## 🐛 常见问题排查

### 问题 0：启动时出现 "RLock(s) were not greened" 警告

**现象：**
```bash
$ osken-manager self_learning_switch.py
2 RLock(s) were not greened, to fix this error make sure you run eventlet.monkey_patch() before importing any other modules.
loading app self_learning_switch.py
...
```

**原因：**
- 这是 **eventlet** 库的警告，不是错误
- OS-Ken 使用 eventlet 进行异步并发处理
- 警告表示某些锁（RLock）没有被"绿色化"（greened）
- 这通常发生在某些模块在 monkey_patch 之前被导入

**影响：**
- ✅ **不影响实验运行**：控制器可以正常工作
- ✅ **可以忽略**：这个警告不会影响功能
- ⚠️ 在某些极端情况下，可能会有轻微的并发性能影响（实验场景基本无影响）

**解决方案（可选）：**

如果你想消除这个警告，可以在文件开头添加 monkey_patch：

```python
# 在 self_learning_switch.py 文件的最开头添加
import eventlet
eventlet.monkey_patch()

from os_ken.base import app_manager
# ... 其他导入
```

**注意：**
- 通常不需要修改，因为 `osken-manager` 命令会处理这些
- 如果添加了 monkey_patch 后出现其他问题，可以删除这行代码
- 实验可以正常进行，这个警告可以忽略

---

### 问题 1：Wireshark 没有自动打开

**解决方案：**
```bash
# 方法 1：手动启动 Wireshark
sudo wireshark
# 然后选择 h3-eth0 接口

# 方法 2：检查是否有图形界面
echo $DISPLAY  # 应该显示 :0 或类似的值

# 方法 3：使用 tshark（命令行）
mininet> h3 tshark -i h3-eth0 &
```

### 问题 2：控制器输出中没有 "Packet matched" 信息

**检查：**
1. 确认使用的是 `self_learning_switch.py` 而不是 `simple_switch.py`
2. 检查代码第 72-73 行的日志输出是否正确
3. 确认目的 MAC 地址已经学习（不是第一次 ping）

### 问题 3：Wireshark 中仍然看到 ICMP 包

**可能原因：**
1. 使用的是 `simple_switch.py` 而不是 `self_learning_switch.py`
2. MAC 地址学习失败
3. 流表下发失败

**排查步骤：**
```bash
# 检查流表是否正确下发
mininet> dpctl dump-flows

# 应该看到类似输出：
# cookie=0x0, duration=..., table=0, n_packets=..., ..., actions=output:2
```

### 问题 4：hard_timeout 修改后没有效果

**检查：**
1. 确认修改了正确的文件（`self_learning_switch.py`）
2. 重启控制器（Ctrl+C 后重新运行）
3. 清理 Mininet 环境（`sudo mn -c`）
4. 重新启动实验

---

## ✅ 完成检查清单

### 验证任务 1
- [ ] Wireshark 抓包成功
- [ ] ARP 包正常显示
- [ ] ICMP 包为空或很少（关键验证）
- [ ] 截图已保存

### 验证任务 2
- [ ] 控制器输出已记录
- [ ] h4 和 h2 的 MAC 地址已识别
- [ ] 通信路径已分析
- [ ] 截图已保存

### 验证任务 3
- [ ] hard_timeout=0 测试完成
- [ ] hard_timeout=5 测试完成
- [ ] 输出差异已分析
- [ ] 原因已说明
- [ ] 截图已保存

---

**祝实验顺利！** 🎉

